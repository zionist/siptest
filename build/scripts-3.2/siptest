#!/home/slaviann/work/teligent/loadtest/siptest/env2/bin/python
import logging
import sys
from collections import OrderedDict
from optparse import OptionParser

from siptest.client import ReceiverFactory, SenderFactory
from siptest.common.constants import SIP_HOST, SIP_PORT, RUNS_COUNT, \
    CALL_DURATION, INTERVAL
from siptest.common.utils import make_processes, run_receiver, run_sender


if __name__ == '__main__':
    usage = "usage: %prog [host:port] -f <testfile> [options]"
    optp = OptionParser(usage=usage)
    # Output verbosity options.
    optp.add_option('-q', '--quiet', help='set logging to ERROR',
                    action='store_const', dest='loglevel',
                    const=logging.ERROR, default=logging.INFO)
    optp.add_option('-v', '--verbose', help='set logging to DEBUG',
                    action='store_const', dest='loglevel',
                    const=5, default=logging.INFO)
    optp.add_option('-f', '--file',
                    help='file with MSISDN:pass format',
                    dest='filename')
    optp.add_option('-i', '--interval',
                    help='interval between client start seconds (float)',
                    dest='interval', default=INTERVAL, type='float')
    optp.add_option('-d', '--duration',
                    help='call duration in seconds', type='int',
                    dest='duration', default=CALL_DURATION)
    optp.add_option('-r', '--runs',
                    help='runs count for each call', type='int',
                    dest='runs', default=RUNS_COUNT)

    opts, args = optp.parse_args()

    host = None
    port = None
    if not len(args):
        host = SIP_HOST
        port = SIP_PORT
    elif len(args) == 1:
        (host, port) = args[0].split(":")
    if len(args) > 1:
        print("Please set only one host")

    setattr(opts, "host", host)
    setattr(opts, "port", port)

    logging.basicConfig(level=opts.loglevel,
                        format='%(levelname)-8s %(message)s')

    if not opts.filename:
        print("Please specify the filename for tests")
        optp.print_help()
        sys.exit(1)

    user_file_data = ""
    try:
        with open(opts.filename, 'r') as user_file:
            user_file_data = user_file.readlines()
    except (FileExistsError, FileNotFoundError) as e:
        print("Can't read file %s" % opts.filename)
        print(e)

    # parse file
    users = OrderedDict()
    for line in user_file_data:
        (msisdn, password) = line.rstrip().split(":")
        users.update({msisdn: password})

    if len(users) % 2:
        print("Please check file %s. Count of lines must be even")
        sys.exit(1)

    # distribute senders and receivers to workers
    is_receiver = True
    senders = []
    receivers = []

    for msisdn, password in users.items():
        if is_receiver:
            receivers.append(ReceiverFactory(msisdn, password, opts))
            is_receiver = not is_receiver
        else:
            senders.append(SenderFactory(msisdn, password, opts,
                                  to=receivers[-1].msisdn))
            is_receiver = not is_receiver

    procs = []
    receivers = make_processes(receivers, options=opts, run_func=run_receiver)
    procs.extend(receivers)
    senders = make_processes(senders, options=opts, run_func=run_sender)
    procs.extend(senders)
    for proc in procs:
        proc.daemon = True
        proc.start()
    for proc in procs:
        proc.join()
        logging.debug("Proc joined")
    sys.exit(0)
